<!DOCTYPE html>
<html lang="zh-cmn-Hans" prefix="og: http://ogp.me/ns#" class="han-init">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <title>Android 源码分析 —— Handler、Looper 和 MessageQueue &mdash; J Diary</title>
    <link rel="stylesheet" href="http://localhost:4000/assets/vendor/primer-css/css/primer.css">
    <link rel="stylesheet" href="http://localhost:4000/assets/vendor/primer-markdown/dist/user-content.min.css">
    <link rel="stylesheet" href="http://localhost:4000/assets/vendor/octicons/octicons/octicons.css">
    <link rel="stylesheet" href="http://localhost:4000/assets/css/components/collection.css">
    <link rel="stylesheet" href="http://localhost:4000/assets/css/components/repo-card.css">
    <link rel="stylesheet" href="http://localhost:4000/assets/css/sections/repo-list.css">
    <link rel="stylesheet" href="http://localhost:4000/assets/css/sections/mini-repo-list.css">
    <link rel="stylesheet" href="http://localhost:4000/assets/css/components/boxed-group.css">
    <link rel="stylesheet" href="http://localhost:4000/assets/css/globals/common.css">
    <link rel="stylesheet" href="http://localhost:4000/assets/vendor/share.js/dist/css/share.min.css">
    <link rel="stylesheet" href="http://localhost:4000/assets/css/globals/responsive.css">
    <link rel="stylesheet" href="http://localhost:4000/assets/css/posts/index.css">
    <!-- Latest compiled and minified CSS -->
    

    
    <link rel="canonical" href="http://localhost:4000/2018/06/11/handler-looper-massagequeue/">
    <link rel="alternate" type="application/atom+xml" title="J Diary" href="http://localhost:4000/feed.xml">
    <link rel="shortcut icon" href="http://localhost:4000/favicon.ico">
    
    <meta property="og:title" content="Android 源码分析 —— Handler、Looper 和 MessageQueue">
      
    <meta name="keywords" content="Android, Handler, Looper, Message, MessageQueue">
    <meta name="og:keywords" content="Android, Handler, Looper, Message, MessageQueue">
      
    <meta name="description" content="本系列文章在 https://github.com/mzlogin/rtfsc-android 持(jing)续(chang)更(duan)新(geng)中，欢迎有兴趣的童鞋们关注。">
    <meta name="og:description" content="本系列文章在 https://github.com/mzlogin/rtfsc-android 持(jing)续(chang)更(duan)新(geng)中，欢迎有兴趣的童鞋们关注。">
      
    
    
        
    
    <meta property="og:url" content="http://localhost:4000/2018/06/11/handler-looper-massagequeue/">
    <meta property="og:site_name" content="J Diary">
    <meta property="og:type" content="article">
    <meta property="og:locale" content="zh_CN" />
    
    <meta property="article:published_time" content="2018-06-11">
    
    <script src="http://localhost:4000/assets/vendor/jquery/dist/jquery.min.js"></script>
    <script src="http://localhost:4000/assets/js/jquery-ui.js"></script>
    <script src="http://localhost:4000/assets/js/main.js"></script>
</head>
<body class="" data-mz="">
    <header class="site-header">
        <div class="container">
            <h1><a href="http://localhost:4000/" title="J Diary"><span class="octicon octicon-mark-github"></span> J Diary</a></h1>
            <button class="collapsed mobile-visible" type="button" onclick="toggleMenu();">
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
            </button>
            <nav class="site-header-nav" role="navigation">
                
                <a href="http://localhost:4000/" class=" site-header-nav-item" target="" title="Home">Home</a>
                
                <a href="http://localhost:4000/categories/" class=" site-header-nav-item" target="" title="Categories">Categories</a>
                
                <a href="http://localhost:4000/about/" class=" site-header-nav-item" target="" title="About">About</a>
                
            </nav>
        </div>
    </header>
    <!-- / header -->

    <section class="collection-head small geopattern" data-pattern-id="Android 源码分析 ——">
<div class="container">
  <div class="columns">
    <div class="column three-fourths">
      <div class="collection-title">
        <h1 class="collection-header">Android 源码分析 —— Handler、Looper 和 MessageQueue</h1>
        <div class="collection-info">
          
          <span class="meta-info">
            <span class="octicon octicon-calendar"></span> 2018/06/11
          </span>
          
          
          <span class="meta-info">
            <span class="octicon octicon-file-directory"></span>
            <a href="http://localhost:4000/categories/#Android" title="Android">Android</a>
          </span>
          
        </div>
      </div>
    </div>
  </div>
</div>
</section>
<!-- / .banner -->
<section class="container content">
<div class="columns">
  <div class="column three-fourths" >
    <article class="article-content markdown-body">
    <p>本系列文章在 <a href="https://github.com/mzlogin/rtfsc-android">https://github.com/mzlogin/rtfsc-android</a> 持(jing)续(chang)更(duan)新(geng)中，欢迎有兴趣的童鞋们关注。</p>

<p>书接上文，在分析 Toast 源码的过程中我们涉及到了 Handler，这个在 Android 开发里经常用到的类——线程切换、顺序执行、延时执行等等逻辑里往往少不了它的身影，跟它一起搭配使用的通常是 Runnable 和 Message，还有它身后的好基友 Looper 与 MessageQueue。Runnable 相信大家都很熟悉了，本文的主角就是标题里的三剑客——Handler、Looper 和 MessageQueue，当然少不了说到 Message。</p>

<p>本文使用的工具与源码为：Chrome、插件 insight.io、GitHub 项目 <a href="https://github.com/aosp-mirror/platform_frameworks_base">aosp-mirror/platform_frameworks_base</a></p>

<p><strong>目录</strong></p>

<ul id="markdown-toc">
  <li><a href="#初步印象" id="markdown-toc-初步印象">初步印象</a>    <ul>
      <li><a href="#handler" id="markdown-toc-handler">Handler</a></li>
      <li><a href="#looper" id="markdown-toc-looper">Looper</a></li>
      <li><a href="#messagequeue" id="markdown-toc-messagequeue">MessageQueue</a></li>
      <li><a href="#message" id="markdown-toc-message">Message</a></li>
    </ul>
  </li>
  <li><a href="#提出问题" id="markdown-toc-提出问题">提出问题</a></li>
  <li><a href="#解答问题" id="markdown-toc-解答问题">解答问题</a>    <ul>
      <li><a href="#thread-与-looper" id="markdown-toc-thread-与-looper">Thread 与 Looper</a></li>
      <li><a href="#looper-与-messagequeue" id="markdown-toc-looper-与-messagequeue">Looper 与 MessageQueue</a></li>
      <li><a href="#handler-与-looper" id="markdown-toc-handler-与-looper">Handler 与 Looper</a></li>
      <li><a href="#消息如何分发到对应的-handler" id="markdown-toc-消息如何分发到对应的-handler">消息如何分发到对应的 Handler</a></li>
      <li><a href="#handler-能用于线程切换的原理" id="markdown-toc-handler-能用于线程切换的原理">Handler 能用于线程切换的原理</a></li>
      <li><a href="#runnable-与-messagequeue" id="markdown-toc-runnable-与-messagequeue">Runnable 与 MessageQueue</a></li>
      <li><a href="#能否创建关联到其它线程的-handler" id="markdown-toc-能否创建关联到其它线程的-handler">能否创建关联到其它线程的 Handler</a></li>
      <li><a href="#消息可以插队吗" id="markdown-toc-消息可以插队吗">消息可以插队吗</a></li>
      <li><a href="#消息可以撤回吗" id="markdown-toc-消息可以撤回吗">消息可以撤回吗</a></li>
      <li><a href="#找到主线程消息循环源码" id="markdown-toc-找到主线程消息循环源码">找到主线程消息循环源码</a></li>
    </ul>
  </li>
  <li><a href="#总结" id="markdown-toc-总结">总结</a>    <ul>
      <li><a href="#结论汇总" id="markdown-toc-结论汇总">结论汇总</a></li>
      <li><a href="#遗留知识点" id="markdown-toc-遗留知识点">遗留知识点</a></li>
      <li><a href="#本篇用到的源码分析方法" id="markdown-toc-本篇用到的源码分析方法">本篇用到的源码分析方法</a></li>
    </ul>
  </li>
  <li><a href="#后话" id="markdown-toc-后话">后话</a></li>
</ul>

<h2 id="初步印象">初步印象</h2>

<p>按惯例，第一步还是从 Android 的官方 API 文档里来建立对这几个类的初步印象，文档开头的说明里往往有一些比较关键的知识点。</p>

<p>官方文档链接：</p>

<ul>
  <li><a href="https://developer.android.google.cn/reference/android/os/Handler">Handler</a></li>
  <li><a href="https://developer.android.google.cn/reference/android/os/Looper">Looper</a></li>
  <li><a href="https://developer.android.google.cn/reference/android/os/MessageQueue">MessageQueue</a></li>
  <li><a href="https://developer.android.google.cn/reference/android/os/Message">Message</a></li>
</ul>

<p>这几个类开头的说明本身也不长，为了避免断章取义误人子弟，就将其直译版完整地放在下面，当然更推荐的方式是自己去看原文。</p>

<h3 id="handler">Handler</h3>

<p>可以用 Handler 发送和处理与某线程的 MessageQueue 相关联的 Message/Runnable 对象。每个 Handler 实例只能与一个线程和它的消息队列相关联。当创建一个 Handler 时，它会绑定到当前线程和消息队列——从那时起，它将 Message 和 Runnable 传递给绑定的消息队列，并在它们从队列里被取出时执行对应逻辑。（<em>译注：此处描述不准确，创建 Handler 时并不一定是绑定到当前线程。</em>）</p>

<p>Handler 主要有两个用途：</p>

<ol>
  <li>
    <p>在未来某个时间点处理 Messages 或者执行 Runnables；</p>
  </li>
  <li>
    <p>将一段逻辑切换到另一个线程执行。</p>
  </li>
</ol>

<p>可以使用 Handler 的以下方法来调度 Messages 和 Runnables：</p>

<ul>
  <li>
    <p>post(Runnable)</p>
  </li>
  <li>
    <p>postAtTime(Runnable, long)</p>
  </li>
  <li>
    <p>postDelayed(Runnable, Object, long)</p>
  </li>
  <li>
    <p>sendEmptyMessage(int)</p>
  </li>
  <li>
    <p>sendMessage(Message)</p>
  </li>
  <li>
    <p>sendMessageAtTime(Message, long)</p>
  </li>
  <li>
    <p>sendMessageDelayed(Message, long)</p>
  </li>
</ul>

<p>其中 postXXX 系列用于将 Runnable 对象加入队列，sendXXX 系列用于将 Message 对象加入队列，Message 对象通常会携带一些数据，可以在 Handler 的 handlerMessage(Message) 方法中处理（需要实现一个 Handler 子类）。</p>

<p>在调用 Handler 的 postXXX 和 sendXXX 时，可以指定当队列准备好时立即处理它们，也可以指定延时一段时间后处理，或某个绝对时间点处理。后面这两种能实现超时、延时、周期循环及其它基于时间的行为。</p>

<p>为应用程序创建一个进程时，其主线程专用于运行消息队列，该消息队列负责管理顶层应用程序对象（activities，broadcast receivers 等）以及它们创建的窗口。我们可以创建自己的线程，然后通过 Handler 与主线程进行通信，方法是从新线程调用我们前面讲到的 postXXX 或 sendXXX 方法，传递的 Runnable 或 Message 将被加入 Handler 关联的消息队列中，并适时进行处理。</p>

<h3 id="looper">Looper</h3>

<p>用于为线程执行消息循环的类。线程默认没有关联的消息循环，如果要创建一个，可以在执行消息循环的线程里面调用 prepare() 方法，然后调用 loop() 处理消息，直到循环停止。</p>

<p>大多数与消息循环的交互都是通过 Handler 类。</p>

<p>下面是实现一个 Looper 线程的典型例子，在 prepare() 和 loop() 之间初始化 Handler 实例，用于与 Looper 通信：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">LooperThread</span> <span class="kd">extends</span> <span class="n">Thread</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="n">Handler</span> <span class="n">mHandler</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">Looper</span><span class="o">.</span><span class="na">prepare</span><span class="o">();</span>

        <span class="n">mHandler</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Handler</span><span class="o">()</span> <span class="o">{</span>
            <span class="kd">public</span> <span class="kt">void</span> <span class="nf">handleMessage</span><span class="o">(</span><span class="n">Message</span> <span class="n">msg</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// 在这里处理传入的消息</span>
            <span class="o">}</span>
        <span class="o">};</span>

        <span class="n">Looper</span><span class="o">.</span><span class="na">loop</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="messagequeue">MessageQueue</h3>

<p>持有将被 Looper 分发的消息列表的底层类。消息都是通过与 Looper 关联的 Handler 添加到 MessageQueue，而不是直接操作 MessageQueue。</p>

<p>可以用 Looper.myQueue() 获取当前线程的 MessageQueue 实例。</p>

<h3 id="message">Message</h3>

<p>定义一个可以发送给 Handler 的消息，包含描述和任意数据对象。消息对象有两个额外的 int 字段和一个 object 字段，这可以满足大部分场景的需求了。</p>

<blockquote>
  <p>虽然 Message 的构造方法是 public 的，但最推荐的得到一个消息对象的方式是调用 Message.obtain() 或者 Handler.obtainMessage() 系列方法，这些方法会从一个对象回收池里捡回能复用的对象。</p>
</blockquote>

<h2 id="提出问题">提出问题</h2>

<p>根据以上印象，及以前的使用经验，提出以下问题来继续本次源码分析之旅：</p>

<ol>
  <li>
    <p>Thread 与 Looper，Looper 与 MessageQueue，Handler 与 Looper 之间的数量对应关系是怎样的？</p>
  </li>
  <li>
    <p>如果 Looper 能对应多个 Handler，那通过不同的 Handler 发送的 Message，那处理的时候代码是如何知道该分发到哪一个 Handler 的 handlerMessage 方法的？</p>
  </li>
  <li>
    <p>Handler 能用于线程切换的原理是什么？</p>
  </li>
  <li>
    <p>Runnable 对象也是被添加到 MessageQueue 里吗？</p>
  </li>
  <li>
    <p>可以在 A 线程创建 Handler 关联到 B 线程及其消息循环吗？</p>
  </li>
  <li>
    <p>如何退出消息循环？</p>
  </li>
  <li>
    <p>消息可以插队吗？</p>
  </li>
  <li>
    <p>消息可以撤回吗？</p>
  </li>
  <li>
    <p>上文提到，应用程序的主线程是运行一个消息循环，在代码里是如何反映的？</p>
  </li>
</ol>

<h2 id="解答问题">解答问题</h2>

<h3 id="thread-与-looper">Thread 与 Looper</h3>

<p>前文有提到，线程默认是没有消息循环的，需要调用 Looper.prepare() 来达到目的，那么我们对这个问题的探索就从 Looper.prepare() 开始。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/** Initialize the current thread as a looper.
 * This gives you a chance to create handlers that then reference
 * this looper, before actually starting the loop. Be sure to call
 * {@link #loop()} after calling this method, and end it by calling
 * {@link #quit()}.
 */</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">prepare</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">prepare</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">prepare</span><span class="o">(</span><span class="kt">boolean</span> <span class="n">quitAllowed</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">sThreadLocal</span><span class="o">.</span><span class="na">get</span><span class="o">()</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="s">"Only one Looper may be created per thread"</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="n">sThreadLocal</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="k">new</span> <span class="n">Looper</span><span class="o">(</span><span class="n">quitAllowed</span><span class="o">));</span>
<span class="o">}</span>
</code></pre></div></div>

<p>在有参数版本的 prepare 方法里，我们可以得到两个信息：</p>

<ol>
  <li>
    <p>一个线程里调用多次 Looper.prepare() 会抛出异常，提示 <code class="highlighter-rouge">Only one Looper may be created per thread</code>，即 <strong>一个线程只能创建一个 Looper</strong></p>
  </li>
  <li>
    <p>prepare 里主要干的事就是 <code class="highlighter-rouge">sThreadLocal.set(new Looper(quitAllowed))</code></p>
  </li>
</ol>

<p>源码里是怎么限制一个线程只能创建一个 Looper 的呢？调用多次 Looper.prepare() 并不会关联多个 Looper，还会抛出异常，那能不能直接 new 一个 Looper 关联上呢？答案是不可以，Looper 的构造方法是 private 的。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="nf">Looper</span><span class="o">(</span><span class="kt">boolean</span> <span class="n">quitAllowed</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">mQueue</span> <span class="o">=</span> <span class="k">new</span> <span class="n">MessageQueue</span><span class="o">(</span><span class="n">quitAllowed</span><span class="o">);</span>
    <span class="n">mThread</span> <span class="o">=</span> <span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>

<p>在概览整个 Looper 的所有公开方法后，发现只有 prepare 和 prepareMainLooper 是做线程与 Looper 关联的工作的，而 prepareMainLooper 是 Android 环境调用的，不是用来给应用主动调用的。所以从 Looper 源码里掌握的信息来看，想给一个线程关联多个 Looper 的路不通。</p>

<p>另外我们从源码里能观察到，Looper 有一个 final 的 mThread 成员，在构造 Looper 对象的时候赋值为 <code class="highlighter-rouge">Thread.currentThread()</code>，源码里再无可以修改 mThread 值的地方，所以可知 <strong>Looper 只能关联到一个线程，且关联之后不能改变</strong>。</p>

<p>说了这么多，还记得 Looper.prepare() 里干的主要事情是 <code class="highlighter-rouge">sThreadLocal.set(new Looper(quitAllowed))</code> 吗？与之对应的，获取本线程关联的 Looper 对象是使用静态方法 Looper.myLooper()：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// sThreadLocal.get() will return null unless you've called prepare().</span>
<span class="kd">static</span> <span class="kd">final</span> <span class="n">ThreadLocal</span><span class="o">&lt;</span><span class="n">Looper</span><span class="o">&gt;</span> <span class="n">sThreadLocal</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ThreadLocal</span><span class="o">&lt;</span><span class="n">Looper</span><span class="o">&gt;();</span>

<span class="c1">// ...</span>

<span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">prepare</span><span class="o">(</span><span class="kt">boolean</span> <span class="n">quitAllowed</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">sThreadLocal</span><span class="o">.</span><span class="na">get</span><span class="o">()</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="s">"Only one Looper may be created per thread"</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="n">sThreadLocal</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="k">new</span> <span class="n">Looper</span><span class="o">(</span><span class="n">quitAllowed</span><span class="o">));</span>
<span class="o">}</span>

<span class="c1">// ...</span>

<span class="cm">/**
 * Return the Looper object associated with the current thread.  Returns
 * null if the calling thread is not associated with a Looper.
 */</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="nd">@Nullable</span> <span class="n">Looper</span> <span class="nf">myLooper</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">sThreadLocal</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>

<p>使用了 ThreadLocal 来确保不同的线程调用静态方法 Looper.myLooper() 获取到的是与各自线程关联的 Looper 对象。关于 ThreadLocal，又可以另开一个小话题了。</p>

<p><strong>小结：</strong> Thread 若与 Looper 关联，将会是一一对应的关系，且关联后关系无法改变。</p>

<h3 id="looper-与-messagequeue">Looper 与 MessageQueue</h3>

<p>直接来看源码：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">Looper</span> <span class="o">{</span>
    <span class="c1">// ...</span>
    <span class="kd">final</span> <span class="n">MessageQueue</span> <span class="n">mQueue</span><span class="o">;</span>

    <span class="c1">// ...</span>

    <span class="kd">private</span> <span class="nf">Looper</span><span class="o">(</span><span class="kt">boolean</span> <span class="n">quitAllowed</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">mQueue</span> <span class="o">=</span> <span class="k">new</span> <span class="n">MessageQueue</span><span class="o">(</span><span class="n">quitAllowed</span><span class="o">);</span>
        <span class="c1">// ...</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Looper 对象里有一个 MessageQueue 类型成员，在构造的时候 new 出的，并且它是一个 final，没有地方能修改它的指向。</p>

<p><strong>小结：</strong> Looper 与 MessageQueue 是一一对应的关系。</p>

<h3 id="handler-与-looper">Handler 与 Looper</h3>

<p>在前面略读 Looper 源码的过程中，我发现 Handler 基本没有出场，那么现在，从构造 Handler 的方法开始分析。</p>

<p>Handler 的构造方法有 7 个之多，不过有 3 个标记为 <code class="highlighter-rouge">@hide</code>，所以我们可以直接调用的有 4 个，这 4 个最终调用都到了其它的两个构造方法，捡出来我们要看的重点：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Handler</span> <span class="o">{</span>
    <span class="c1">// ...</span>
    
    <span class="cm">/**
     * ...
     * @hide
     */</span>
    <span class="kd">public</span> <span class="nf">Handler</span><span class="o">(</span><span class="n">Callback</span> <span class="n">callback</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">async</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// ...</span>
        <span class="n">mLooper</span> <span class="o">=</span> <span class="n">Looper</span><span class="o">.</span><span class="na">myLooper</span><span class="o">();</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">mLooper</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span>
                    <span class="s">"Can't create handler inside thread that has not called Looper.prepare()"</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="n">mQueue</span> <span class="o">=</span> <span class="n">mLooper</span><span class="o">.</span><span class="na">mQueue</span><span class="o">;</span>
        <span class="c1">// ...</span>
    <span class="o">}</span>

    <span class="cm">/**
     * ...
     * @hide
     */</span>
    <span class="kd">public</span> <span class="nf">Handler</span><span class="o">(</span><span class="n">Looper</span> <span class="n">looper</span><span class="o">,</span> <span class="n">Callback</span> <span class="n">callback</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">async</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">mLooper</span> <span class="o">=</span> <span class="n">looper</span><span class="o">;</span>
        <span class="n">mQueue</span> <span class="o">=</span> <span class="n">mLooper</span><span class="o">.</span><span class="na">mQueue</span><span class="o">;</span>
        <span class="c1">// ...</span>
    <span class="o">}</span>

    <span class="c1">// ...</span>

    <span class="kd">final</span> <span class="n">Looper</span> <span class="n">mLooper</span><span class="o">;</span>
    <span class="kd">final</span> <span class="n">MessageQueue</span> <span class="n">mQueue</span><span class="o">;</span>
    <span class="c1">// ...</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Handler 对象里有 final Looper 成员，所以一个 Handler 只会对应一个固定的 Looper 对象。构造 Handler 对象的时候如果不传 Looper 参数，会默认使用当前线程关联的 Looper，如果当前线程没有关联 Looper，会抛出异常。</p>

<p>那么能不能绑定多个 Handler 到同一个 Looper 呢？答案是可以的。在源码里并没有找到相关的限制说明，所以这种适合用个小 Demo 来验证，例如以下例子，就绑定了两个 Handler 到主线程的 Looper 上，并都能正常使用（日志 <code class="highlighter-rouge">receive msg: 1</code> 和 <code class="highlighter-rouge">receive msg: 2</code> 能依次输出）。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MainActivity</span> <span class="kd">extends</span> <span class="n">AppCompatActivity</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">TAG</span> <span class="o">=</span> <span class="n">MainActivity</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getSimpleName</span><span class="o">();</span>

    <span class="kd">private</span> <span class="n">Handler</span> <span class="n">mHandler1</span><span class="o">;</span>
    <span class="kd">private</span> <span class="n">Handler</span> <span class="n">mHandler2</span><span class="o">;</span>

    <span class="kd">private</span> <span class="n">Handler</span><span class="o">.</span><span class="na">Callback</span> <span class="n">mCallback</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Handler</span><span class="o">.</span><span class="na">Callback</span><span class="o">()</span> <span class="o">{</span>
        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">handleMessage</span><span class="o">(</span><span class="n">Message</span> <span class="n">msg</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">Log</span><span class="o">.</span><span class="na">v</span><span class="o">(</span><span class="n">TAG</span><span class="o">,</span> <span class="s">"receive msg: "</span> <span class="o">+</span> <span class="n">msg</span><span class="o">.</span><span class="na">what</span><span class="o">);</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">};</span>

    <span class="nd">@Override</span>
    <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">onCreate</span><span class="o">(</span><span class="n">Bundle</span> <span class="n">savedInstanceState</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">.</span><span class="na">onCreate</span><span class="o">(</span><span class="n">savedInstanceState</span><span class="o">);</span>
        <span class="n">setContentView</span><span class="o">(</span><span class="n">R</span><span class="o">.</span><span class="na">layout</span><span class="o">.</span><span class="na">activity_main</span><span class="o">);</span>

        <span class="n">mHandler1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Handler</span><span class="o">(</span><span class="n">mCallback</span><span class="o">);</span>
        <span class="n">mHandler2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Handler</span><span class="o">(</span><span class="n">mCallback</span><span class="o">);</span>

        <span class="n">mHandler1</span><span class="o">.</span><span class="na">sendEmptyMessage</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
        <span class="n">mHandler2</span><span class="o">.</span><span class="na">sendEmptyMessage</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><strong>小结：</strong> Handler 与 Looper 是多对一的关系，创建 Handler 实例时要么提供一个 Looper 实例，要么当前线程有关联的 Looper。</p>

<h3 id="消息如何分发到对应的-handler">消息如何分发到对应的 Handler</h3>

<p>因为消息的分发在是 Looper.loop() 这个过程中，所以我们先来看这个方法：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">loop</span><span class="o">()</span> <span class="o">{</span>
    <span class="c1">// ...</span>
    <span class="k">for</span> <span class="o">(;;)</span> <span class="o">{</span>
        <span class="n">Message</span> <span class="n">msg</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="na">next</span><span class="o">();</span> <span class="c1">// might block</span>
        <span class="c1">// ...</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">msg</span><span class="o">.</span><span class="na">target</span><span class="o">.</span><span class="na">dispatchMessage</span><span class="o">(</span><span class="n">msg</span><span class="o">);</span>
            <span class="c1">// ...</span>
        <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
            <span class="c1">// ...</span>
        <span class="o">}</span>
        <span class="c1">// ...</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>这个方法里做的主要工作是从 MessageQueue 里依次取出 Message，然后调用 Message.target.dispatchMessage 方法，Message 对象的这个 target 成员是什么东东呢？它是一个 Handler，它最终会被设置成 sendMessage 的 Handler：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Handler</span> <span class="o">{</span>
    <span class="c1">// 其它 Handler.sendXXX 方法最终都会调用到这个方法</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">sendMessageAtTime</span><span class="o">(</span><span class="n">Message</span> <span class="n">msg</span><span class="o">,</span> <span class="kt">long</span> <span class="n">uptimeMillis</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// ...</span>
        <span class="k">return</span> <span class="nf">enqueueMessage</span><span class="o">(</span><span class="n">queue</span><span class="o">,</span> <span class="n">msg</span><span class="o">,</span> <span class="n">uptimeMillis</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="c1">// ...</span>
    <span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">enqueueMessage</span><span class="o">(</span><span class="n">MessageQueue</span> <span class="n">queue</span><span class="o">,</span> <span class="n">Message</span> <span class="n">msg</span><span class="o">,</span> <span class="kt">long</span> <span class="n">uptimeMillis</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">msg</span><span class="o">.</span><span class="na">target</span> <span class="o">=</span> <span class="k">this</span><span class="o">;</span> <span class="c1">// 就是这里了</span>
        <span class="c1">// ...</span>
    <span class="o">}</span>
    <span class="c1">// ...</span>
<span class="o">}</span>
</code></pre></div></div>

<p>所以是用哪个 Handler.sendMessage，最终就会调用到它的 dispatchMessage 方法：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">handleCallback</span><span class="o">(</span><span class="n">Message</span> <span class="n">message</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">message</span><span class="o">.</span><span class="na">callback</span><span class="o">.</span><span class="na">run</span><span class="o">();</span>
<span class="o">}</span>
<span class="c1">// ...</span>
<span class="cm">/**
 * Handle system messages here.
 */</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">dispatchMessage</span><span class="o">(</span><span class="n">Message</span> <span class="n">msg</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">msg</span><span class="o">.</span><span class="na">callback</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">handleCallback</span><span class="o">(</span><span class="n">msg</span><span class="o">);</span>
    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">mCallback</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">mCallback</span><span class="o">.</span><span class="na">handleMessage</span><span class="o">(</span><span class="n">msg</span><span class="o">))</span> <span class="o">{</span>
                <span class="k">return</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="n">handleMessage</span><span class="o">(</span><span class="n">msg</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>消息分发到这个方法以后，执行优先级分别是 Message.callback、Handler.mCallback，最后才是 Handler.handleMesage 方法。</p>

<p><strong>小结：</strong> 在 Handler.sendMessage 时，会将 Message.target 设置为该 Handler 对象，这样从消息队列取出 Message 后，就能调用到该 Handler 的 dispatchMessage 方法来进行处理。</p>

<h3 id="handler-能用于线程切换的原理">Handler 能用于线程切换的原理</h3>

<p>实际上一小节的结论已经近乎揭示了其中的原理，进一步解释一下就是：</p>

<p><strong>小结：</strong> Handler 会对应一个 Looper 和 MessageQueue，而 Looper 与线程又一一对应，所以通过 Handler.sendXXX 和 Hanler.postXXX 添加到 MessageQueue 的 Message，会在这个对应的线程的 Looper.loop() 里取出来，并就地执行 Handler.dispatchMessage，这就可以完成线程切换了。</p>

<h3 id="runnable-与-messagequeue">Runnable 与 MessageQueue</h3>

<p>Handler 的 postXXX 系列方法用于调度 Runnable 对象，那它最后也是和 Message 一样被加到 MessageQueue 的吗？可是 MessageQueue 是用一个元素类型为 Message 的链表来维护消息队列的，类型不匹配。</p>

<p>在 Handler 源码里能找到答案，这里就以 Handler.post(Runnable) 方法为例，其它几个 postXXX 方法情形与此类似。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * Causes the Runnable r to be added to the message queue.
 * The runnable will be run on the thread to which this handler is 
 * attached. 
 *  
 * @param r The Runnable that will be executed.
 * 
 * @return Returns true if the Runnable was successfully placed in to the 
 *         message queue.  Returns false on failure, usually because the
 *         looper processing the message queue is exiting.
 */</span>
<span class="kd">public</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">post</span><span class="o">(</span><span class="n">Runnable</span> <span class="n">r</span><span class="o">)</span>
<span class="o">{</span>
    <span class="k">return</span>  <span class="nf">sendMessageDelayed</span><span class="o">(</span><span class="n">getPostMessage</span><span class="o">(</span><span class="n">r</span><span class="o">),</span> <span class="mi">0</span><span class="o">);</span>
<span class="o">}</span>

<span class="c1">// ...</span>

<span class="kd">private</span> <span class="kd">static</span> <span class="n">Message</span> <span class="nf">getPostMessage</span><span class="o">(</span><span class="n">Runnable</span> <span class="n">r</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">Message</span> <span class="n">m</span> <span class="o">=</span> <span class="n">Message</span><span class="o">.</span><span class="na">obtain</span><span class="o">();</span>
    <span class="n">m</span><span class="o">.</span><span class="na">callback</span> <span class="o">=</span> <span class="n">r</span><span class="o">;</span>
    <span class="k">return</span> <span class="n">m</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>可以看到，post 系列方法最终也是调用的 send 系列方法，Runnable 对象是被封装成 Message 对象后加入到消息队列的，Message.callback 被设置为 Runnable 本身，还记得前文 Handler.dispatchMessage 的执行顺序吗？如果 Message.callback 不为空，则执行 Message.callback.run() 后就返回。</p>

<p><strong>小结：</strong> Runnable 被封装成 Message 之后添加到 MessageQueue。</p>

<h3 id="能否创建关联到其它线程的-handler">能否创建关联到其它线程的 Handler</h3>

<p>创建 Handler 时会关联到一个 Looper，而 Looper 是与线程一一绑定的，所以理论上讲，如果能得到要关联的线程的 Looper 实例，这是可以实现的。</p>

<p>在阅读 Looper 源码的过程中，我们有留意到（好吧，其实应该是平时写代码时有用到）：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">Looper</span> <span class="o">{</span>
    <span class="c1">// ...</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="n">Looper</span> <span class="n">sMainLooper</span><span class="o">;</span>  <span class="c1">// guarded by Looper.class</span>
    <span class="c1">// ...</span>
    <span class="cm">/**
     * Returns the application's main looper, which lives in the main thread of the application.
     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="n">Looper</span> <span class="nf">getMainLooper</span><span class="o">()</span> <span class="o">{</span>
        <span class="kd">synchronized</span> <span class="o">(</span><span class="n">Looper</span><span class="o">.</span><span class="na">class</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">sMainLooper</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>可见获取主线程的 Looper 是能实现的，平时写代码过程中，如果要从子线程向主线程添加一段执行逻辑，也经常这么干，这是可行的：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 从子线程创建关联到主线程 Looper 的 Handler</span>
<span class="n">Handler</span> <span class="n">mHandler</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Handler</span><span class="o">(</span><span class="n">Looper</span><span class="o">.</span><span class="na">getMainLooper</span><span class="o">());</span>

<span class="n">mHandler</span><span class="o">.</span><span class="na">post</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
        <span class="c1">// ...</span>
        <span class="o">});</span>
</code></pre></div></div>

<p>从子线程创建关联到其它子线程的 Looper 是否可行呢？这个用 Demo 来验证：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">new</span> <span class="n">Thread</span><span class="o">()</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">setName</span><span class="o">(</span><span class="s">"thread-one"</span><span class="o">);</span>
        <span class="n">Looper</span><span class="o">.</span><span class="na">prepare</span><span class="o">();</span>

        <span class="kd">final</span> <span class="n">Looper</span> <span class="n">threadOneLooper</span> <span class="o">=</span> <span class="n">Looper</span><span class="o">.</span><span class="na">myLooper</span><span class="o">();</span>

        <span class="k">new</span> <span class="nf">Thread</span><span class="o">()</span> <span class="o">{</span>
            <span class="nd">@Override</span>
            <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
                <span class="n">setName</span><span class="o">(</span><span class="s">"thread-two"</span><span class="o">);</span>
                <span class="n">Handler</span> <span class="n">handler</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Handler</span><span class="o">(</span><span class="n">threadOneLooper</span><span class="o">);</span>

                <span class="n">handler</span><span class="o">.</span><span class="na">post</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
                        <span class="n">Log</span><span class="o">.</span><span class="na">v</span><span class="o">(</span><span class="s">"test"</span><span class="o">,</span> <span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">());</span>
                        <span class="o">});</span>
            <span class="o">}</span>
        <span class="o">}.</span><span class="na">start</span><span class="o">();</span>

        <span class="n">Looper</span><span class="o">.</span><span class="na">loop</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}.</span><span class="na">start</span><span class="o">();</span>
</code></pre></div></div>

<p>执行后日志输出为 <code class="highlighter-rouge">thread-one</code>。</p>

<p><strong>小结：</strong> 可以从一个线程创建关联到另一个线程 Looper 的 Handler，只要能拿到对应线程的 Looper 实例。</p>

<h3 id="消息可以插队吗">消息可以插队吗</h3>

<p>这个问题从API 文档、Handler 源码里都可以找到答案，答案是可以的，使用 Handler.sendMessageAtFrontOfQueue 和 Handler.postAtFrontOfQueue 这两个方法，它们会分别将 Message 和 Runnable（封装后）插入到消息队列的队首。</p>

<p>我目前尚未遇到过这种使用场景。</p>

<p><strong>小结：</strong> 消息可以插队，使用 Handler.xxxAtFrontOfQueue 方法。</p>

<h3 id="消息可以撤回吗">消息可以撤回吗</h3>

<p>同上，可以从 Handler 的 API 文档中找到答案。</p>

<p>可以用 Handler.hasXXX 系列方法判断关联的消息队列里是否有等待中的符合条件的 Message 和 Runnable，用 Handler.removeXXX 系列方法从消息队列里移除等待中的符合条件的 Message 和 Runnable。</p>

<p><strong>小结：</strong> 尚未分发的消息是可以撤回的，处理过的就没法了。</p>

<h3 id="找到主线程消息循环源码">找到主线程消息循环源码</h3>

<p>我们前面提到过一个小细节，就是 Looper.prepareMainLooper 是 Android 环境调用的，而从该方法的注释可知，调用它就是为了初始化主线程 Looper，所以我们要找到主线程消息循环这部分源码，搜索 prepareMainLooper 被哪些地方引用即可。</p>

<p>使用 insight.io 插件的功能，在 Looper.prepareMainLooper 上点一下即可看到引用处列表，一共两处：</p>

<p><img src="/images/posts/android/prepare-main-looper.png" alt="" /></p>

<p>从文件路径和文件名上猜测应该是第一处。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">ActivityThread</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// ...</span>
        <span class="n">Looper</span><span class="o">.</span><span class="na">prepareMainLooper</span><span class="o">();</span>
        <span class="c1">// ...</span>
        <span class="n">Looper</span><span class="o">.</span><span class="na">loop</span><span class="o">();</span>
        <span class="c1">// ...</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>就是我想象中的模样。这里只是简单找到这个位置，继续深入探索的话可以开启一个新的话题了，后续的篇章里再解决。</p>

<h2 id="总结">总结</h2>

<h3 id="结论汇总">结论汇总</h3>

<ul>
  <li>
    <p>Thread 若与 Looper 关联，将会是一一对应的关系，且关联后关系无法改变。</p>
  </li>
  <li>
    <p>Looper 与 MessageQueue 是一一对应的关系。</p>
  </li>
  <li>
    <p>Handler 与 Looper 是多对一的关系，创建 Handler 实例时要么提供一个 Looper 实例，要么当前线程有关联的 Looper。</p>
  </li>
  <li>
    <p>在 Handler.sendMessage 时，会将 Message.target 设置为该 Handler 对象，这样从消息队列取出 Message 后，就能调用到该 Handler 的 dispatchMessage 方法来进行处理。</p>
  </li>
  <li>
    <p>Handler 会对应一个 Looper 和 MessageQueue，而 Looper 与线程又一一对应，所以通过 Handler.sendXXX 和 Hanler.postXXX 添加到 MessageQueue 的 Message，会在这个对应的线程的 Looper.loop() 里取出来，并就地执行 Handler.dispatchMessage，这就可以完成线程切换了。</p>
  </li>
  <li>
    <p>Runnable 被封装成 Message 之后添加到 MessageQueue。</p>
  </li>
  <li>
    <p>可以从一个线程创建关联到另一个线程 Looper 的 Handler，只要能拿到对应线程的 Looper 实例。</p>
  </li>
  <li>
    <p>消息可以插队，使用 Handler.xxxAtFrontOfQueue 方法。</p>
  </li>
  <li>
    <p>尚未分发的消息是可以撤回的，处理过的就没法了。</p>
  </li>
</ul>

<h3 id="遗留知识点">遗留知识点</h3>

<ol>
  <li>
    <p>ThreadLocal</p>
  </li>
  <li>
    <p>应用的启动流程</p>
  </li>
</ol>

<h3 id="本篇用到的源码分析方法">本篇用到的源码分析方法</h3>

<ol>
  <li>文档优先</li>
</ol>

<h2 id="后话">后话</h2>

<p>关于 Handler、Looper 和 MessageQueue 的分析在此先告一段落，这部分的内容比较容易分析，但里面细节挺多的，写得有点杂且不全，有点只见树木不见森林的感觉，想要配合画一些图，但找不到合适的画图形式。对此类主题的解析方式必须要再探索优化一下，大家有好的建议请一定告知。</p>

<hr />

<p>最后，照例要安利一下我的微信公众号「闷骚的程序员」，扫码关注，接收 rtfsc-android 的最近更新。</p>

<div align="center"><img width="192px" height="192px" src="https://mazhuang.org/assets/images/qrcode.jpg" /></div>


    </article>
    <div class="share">
      <div class="share-component"></div>
    </div>
    <div class="comment">
      

  

  
        <div id="gitalk-container"></div>
        <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
        <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
        <script>
        var gitalk = new Gitalk({
            id: '/2018/06/11/handler-looper-massagequeue/',
            clientID: '4cef70907f5b36353d59',
            clientSecret: '94b120bec4f51b07c796df03ad3ece5a99f71ed6',
            repo: 'gitalk',
            owner: 'zhenyu0519',
            admin: ['zhenyu0519'],
            labels: ['gitment'],
            perPage: 50,
        })
        gitalk.render('gitalk-container')
        </script>
  


    </div>
  </div>
  <div class="column one-fourth">
    
<h3>Search</h3>
<div id="site_search">
    <input type="text" id="search_box" placeholder="Search">
</div>

<ul id="search_results"></ul>

<link rel="stylesheet" type="text/css" href="http://localhost:4000/assets/css/modules/sidebar-search.css">
<script src="http://localhost:4000/assets/js/simple-jekyll-search.min.js"></script>
<script src="http://localhost:4000/assets/js/search.js"></script>

<script type="text/javascript">
SimpleJekyllSearch({
    searchInput: document.getElementById('search_box'),
    resultsContainer: document.getElementById('search_results'),
    json: 'http://localhost:4000/assets/search_data.json',
    searchResultTemplate: '<li><a href="{url}" title="{desc}">{title}</a></li>',
    noResultsText: 'No results found',
    limit: 10,
    fuzzy: false,
    exclude: ['Welcome']
})
</script>

    

    
<h3 class="post-directory-title mobile-hidden">Table of Contents</h3>
<div id="post-directory-module" class="mobile-hidden">
  <section class="post-directory">
  <!-- Links that trigger the jumping -->
  <!-- Added by javascript below -->
  <dl></dl>
  </section>
</div>

<script src="http://localhost:4000/assets/js/jquery.toc.js"></script>

  </div>
</div>
</section>
<!-- /section.content -->

    <footer class="container">
        <div class="site-footer" role="contentinfo">
            <div class="copyright left mobile-block">
                    © 2019
                    <span title="Jeffrey">Jeffrey</span>
                    <a href="javascript:window.scrollTo(0,0)" class="right mobile-visible">TOP</a>
            </div>

            <ul class="site-footer-links right mobile-hidden">
                <li>
                    <a href="javascript:window.scrollTo(0,0)" >TOP</a>
                </li>
            </ul>
            <a href="https://github.com/zhenyu0519/zhenyu0519.github.io" target="_blank" aria-label="view source code">
                <span class="mega-octicon octicon-mark-github" title="GitHub"></span>
            </a>
            <ul class="site-footer-links mobile-hidden">
                
                <li>
                    <a href="http://localhost:4000/" title="Home" target="">Home</a>
                </li>
                
                <li>
                    <a href="http://localhost:4000/categories/" title="Categories" target="">Categories</a>
                </li>
                
                <li>
                    <a href="http://localhost:4000/about/" title="About" target="">About</a>
                </li>
                
                <li><a href="http://localhost:4000/feed.xml"><span class="octicon octicon-rss" style="color:orange;"></span></a></li>
            </ul>

        </div>
    </footer>
    <div class="tools-wrapper">
      <a class="gotop" href="#" title="回到顶部"><span class="octicon octicon-arrow-up"></span></a>
    </div>
    <!-- / footer -->
    <script src="http://localhost:4000/assets/vendor/share.js/dist/js/share.min.js"></script>
    <script src="http://localhost:4000/assets/js/geopattern.js"></script>
    <script src="http://localhost:4000/assets/js/prism.js"></script>
    <link rel="stylesheet" href="http://localhost:4000/assets/css/globals/prism.css">
    <script>
      jQuery(document).ready(function($) {
        // geopattern
        $('.geopattern').each(function(){
          $(this).geopattern($(this).data('pattern-id'));
        });
       // hljs.initHighlightingOnLoad();
      });
    </script>

    

    

    

    

    
    <div style="display:none">
      <script>
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-113380665-1', 'auto');
        ga('send', 'pageview');

      </script>
    </div>
    
</body>
</html>
