---
layout: post
title: leetcode 53. Maximum Subarray (Python)
categories: Leetcode Dynamic-Programming
description: leetcode 53. Maximum Subarray (Python Solution)
keywords: 2020， Leetcode， Algorithem, Python, leetcode 53, Maximum Subarray, zhenyu
---

# Leetcode 53. Maximum Subarray (Python)

# Related Topic
<a href="/categories/#Dynamic-Programming" target="_blank"> v</a>.

# Description
Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.

## Sample I/O
### Example 1
```
Input: [-2,1,-3,4,-1,2,1,-5,4],
Output: 6
Explanation: [4,-1,2,1] has the largest sum = 6.
```

# Methodology
This question solved by Dynamic Programming.

1. Find the base case
```
dp[0] = nums[0]
```

2. Find the pattern
   The basic idea is append the current value to the subarry of largest sum. 
   1. If the subarray'sum greater than the current value, we keep the value in the subarry and make it become new subarray of largest sum.
   2. If the subarray'sum less than the current value, we abandon the former subarray of largest sum and create a new subarray of largest sum with head index value of current value.

3. To use dynamic programming for this question, we actually do not need continously create or abandon subarray. we can use prefix sum to always get the maxmium sum of previous subarry and compare the current value with this sum. This will lead to same result.


# Code
```python
def maxSubArray(self, nums: List[int]) -> int:
        dp = [0]*len(nums)
        dp[0] = nums[0]
        max_num = nums[0]
        for i in range(1, len(nums)):
            dp[i] = max(dp[i-1]+nums[i], nums[i])
            if dp[i]>max_num: max_num = dp[i]
        return max_num
```

# BigO
We iterate all dp array, it will cost O(n), each current value will compare with the sum of current value and last value, it will cost (1+1), in total will be O(n+n) and It is O(n)
